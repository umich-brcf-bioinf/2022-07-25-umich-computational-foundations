---
title: "R Basics"
output:
        html_document:
            includes:
                in_header: header.html
            theme: paper
            toc: true
            number_sections: false
            fig_caption: false
            markdown: GFM
            code_download: false
---

<style type="text/css">

body, td {
   font-size: 18px;
}
code.r{
  font-size: 12px;
}
pre {
  font-size: 12px
}

</style>

<!--
---
title: "R Basics"
teaching: 60
exercises: 20
questions:
- "What will these lessons not cover?"
- "What are the basic features of the R language?"
- "What are the most common objects in R?"
objectives:
- "Be able to create the most common R objects including vectors"
- "Understand that vectors have modes, which correspond to the type of data they contain"
- "Be able to use arithmetic operators on R objects"
- "Be able to retrieve (subset), name, or replace, values from a vector"
- "Be able to use logical operators in a subsetting operation"
- "Understand that lists can hold data of more than one mode and can be indexed"
keypoints:
- "Effectively using R is a journey of months or years. Still you don't have to be an expert to use R and you can start using and analyzing your data with with about a day's worth of training"
- "It is important to understand how data are organized by R in a given object type and how the mode of that type (e.g. numeric, character, logical, etc.) will determine how R will operate on that data."
- "Working with vectors effectively prepares you for understanding how data are organized in R."
source: Rmd
---
-->

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-")
```

# Overview

In this lesson we will learn the different types of objects in R, how to create them, how to access data in them, and how to operate on them. This lesson will get you thinking about how data can be stored in different forms of objects, and which objects might be best for certain kinds of data.

> ## Reminder
>
> At this point you should be coding along in the "**r_basics.R**" script we created in the last lesson. Writing your commands and comments in the script will make it easier to record what you did and why.
>
> We should also be regularly saving the file by clicking the single floppy disk icon or pressing <KBD>Ctrl + S</KBD>.
<br>

# Getting started with objects

## Creating objects

What might be called a variable in many languages is called an **object** in R (but you can also call it a variable).

**To create an object you need:**

- a name (e.g. 'a')
- a value (e.g. '1')
- the assignment operator ('<-' or '=')

In your script, "**r_basics.R**", using the R assignment operator '<-', assign '1' to the object 'a' as shown. Remember to leave a comment in the line above (using the '#') to explain what you are doing:

```{r, purl = FALSE}
# this line creates the object 'a' and assigns it the value '1'
a <- 1
```

Next, run this line of code in your script. In the RStudio 'Console' you should see:

~~~
> a <- 1
>
~~~


The 'Console' will display lines of code run from a script and any outputs or status/warning/error messages (usually in red).

In the 'Environment' window you will also get a table:

|Values||
|------|-|
|a|1|

The 'Environment' window allows you to keep track of the objects you have created in R.

> ## Exercise: Create some objects
>
> Create the following objects:
>
> 1. Create an object called `human_chr_number` that has the value of number of pairs of human chromosomes
> 2. Create an object called `gene_name` that has the value of your favorite gene name

<details>
<summary>Solution</summary>

Here as some possible answers to the challenge:
```{r, purl = FALSE}
human_chr_number <- 23
gene_name <- 'pten'
```
</details>
<br>

> ## A note on the assignment operator
>
> Many people use `=` as their preferred assignment operator in R instead of `<-`, and this is just as well. Here is a [blog post](https://www.r-bloggers.com/2010/11/assignment-operators-in-r-%E2%80%98%E2%80%99-vs-%E2%80%98-%E2%80%99/) discussing the differences.

## Naming objects

We can't choose any name we like for objects in R, and there are some best practices that may help you write clear, readable code:

- **Avoid spaces and special characters**: Object names cannot contain spaces or the minus sign (`-`). You can use '_' to make names more readable. You should avoid using special characters in your object name (e.g. ! @ # , etc.). Also, object names cannot begin with a number.
- **Use short, easy-to-understand names**: You should avoid naming your objects using single letters (e.g. 'n', 'p', etc.). This is mostly to encourage you to use names that would make sense to anyone reading your code (a colleague, or even yourself a year from now). Also, avoiding excessively long names will make your code more readable.
- **Avoid commonly used names**: There are several names that may already have a definition in the R language (e.g. 'mean', 'min', 'max'). One clue that a name already has meaning is that if you start typing a name in RStudio and it gets a colored highlight or RStudio gives you a suggested autocompletion you have chosen a name that has a reserved meaning.
- **Use the recommended assignment operator**: In R, we use '<- ' as the preferred assignment operator. '=' works too, but is most commonly used in passing arguments to functions (more on functions later). There is a shortcut for the R assignment operator:
  - Windows execution shortcut: <KBD>Alt</KBD>+<KBD>-</KBD>
  - Mac execution shortcut: <KBD>Option</KBD>+<KBD>-</KBD>

There are a few more suggestions about naming and style you may want to learn more about as you write more R code. There are several "style guides" that have advice, and one to start with is the [tidyverse R style guide](http://style.tidyverse.org/index.html).

## Reassigning object names and deleting objects

Once an object has a value, you can change that value by overwriting it. R will not give you a warning or error if you overwriting an object, which may or may not be a good thing depending on how you look at it.

```{r, purl = FALSE}
# gene_name has the value 'pten' or whatever value you used in the challenge.
# We will now assign the new value 'tp53'
gene_name <- 'tp53'
```

You can also remove an object from R's memory entirely. The `rm()` function will delete the object.

```{r, purl = FALSE, eval = FALSE}
# delete the object 'gene_name'
rm(gene_name)
```

If you run a line of code that has only an object name, R will normally display the contents of that object. In this case, we are told the object no longer exists.

~~~
> gene_name
Error: object 'gene_name' not found
~~~

# Objects in R

## Atomic vectors

The most basic object in R is called an "atomic vector" or just a vector. It is a simple vector of data of the same type. You've actually already created two vectors already with the objects `a`, `human_chr_number`, and `gene_name`, they are just vectors of length 1.

Atomic vectors can have many different types. We will illustrate those types with some examples using the `c()`, and we will verify their type by using the `typeof()` function.

### Characters

A character vector contains text.

```{r}
# A vector of countries
countries <- c("Thailand","Lesotho","Suriname","Canada")
typeof(countries)

# A vector of their corresponding continents
continents <- c('Asia', 'Africa', 'South America', 'North America')
typeof(continents)
```

### Doubles / Numerics

A double (or numeric) vector stores real numbers. They can be positive or negative, large or small, and be whole or have decimal representations.

```{r}
country_populations <- c(69950850, 2108328, 575990, 38436447) # Source: Wikipedia
typeof(country_populations)
```

### Integers

Integer vectors store integers, which are whole numbers. It is rather rare to use integer vectors explicitly. Doubles are much more common. An integer vector can be created by adding an `L` after the number, as in:

```{r}
integer_country_populations <- c(69950850L, 2108328L, 575990L, 38436447L)
typeof(integer_country_populations)
```

### Logicals

Logical vectores store `TRUE` or `FALSE`, so Boolean data. Logicals are crucial for doing comparisons as in:

```{r}
3 > 4
```

R interprets both `TRUE` and `FALSE`, in capital letters and without quotes as logical data. The shorthand `T` and `F` may work if they are not defined elsewhere (it's best to always use `TRUE` or `FALSE`).

```{r}
keep_data = c(TRUE, TRUE, FALSE, TRUE)
typeof(keep_data)
```

### Names

Names can be given to the elements of an atomic vector using the `names()` function. This can be useful for keeping track of the elements of the objects. For example, we can alter the `country_populations` vector to have the country as the name of each population:

```{r}
names(country_populations) = c("Thailand","Lesotho","Suriname","Canada")
country_populations
```

Alternatively, we already have a vector of country names in `countries`, so an alternative to the above is:

```{r}
names(country_populations) = countries
country_populations
```

## Factors

Factors are how R stores categorical information, like the continents, among our examples. It is like a character vector that can only have a finite number of values. To make a factor, we can pass an atomic vector into the `factor()` function. In the background, R recodes the data as integers and stores the results in an integer vector. It also adds a `levels` attribute to the integer vector enumerating the set of labels for displaying the factor values. The easiest way to see this is with an example:

```{r}
continents_factor = factor(continents)
continents_factor
typeof(continents_factor)
class(continents_factor)
as.integer(continents_factor)
```

We observe a few things with this string of commands:

1. It looks like the type of `continents_factor` is an integer vector.
2. But there is a class of vectors, called factors. R will often take into account the class of an object to decide how a function will act on it.
3. By default the `levels` of a factor are the unique elements of the character vector in alphabetical order.

You can specify an order by explicitly defining the levels as in:

```{r}
continents_factor = factor(continents, levels = c('South America', 'Asia', 'Africa', 'North America'))
continents_factor
as.integer(continents_factor)
```

Notice that the integer representation of the vector changed order, because the levels changed order. This will be useful later in the RNA-seq Demystified lessons when we discuss testing for differential expression.

## Matrices and Arrays

A matrix stores values in a two-dimensional array, as in a matrix from linear algebra. A matrix must store data that is all the same type. We can create a matrix from a vector by using the `matrix()` function and specifying the number of rows (or columns), as with:

```{r}
country_matrix = matrix(countries, nrow = 2)
country_matrix
typeof(country_matrix)
class(country_matrix)
```

Notice again here, that the type and class of the matrices are different. R thinks of a matrix as a special case of an atomic vector, that is, one that has two dimensions. Let's look at another example using the `country_populations` vector.

```{r}
population_matrix = matrix(country_populations, nrow = 2)
population_matrix
typeof(population_matrix)
class(population_matrix)
```

For these lessons, we will not focus very much on matrices other than for this introduction. We wanted to introduce the idea, as you are very likely to encounter matrices when working with certain libraries and performing certain analyses.

If a matrix is two-dimensional (with rows and columns) and the contents are of a single type (e.g. `double`), then an array is an n-dimensional matrix. We will not go into arrays in these lessons.

## Lists

Lists are like atomic vectors in that they group data into a one-dimensional set, but lists group together **other R objects**, such as atomic vectors or other lists. The best way to see this is with an example:

```{r}
country_list = list(countries, continents, country_populations)
country_list
typeof(country_list)
```

Notice that the list contains three atomic vectors, the types of the atomic vectors don't have to be the same. In fact, the length of the atomic vectors don't even have to be the same.

As with vectors, the elements of a list can be named. We can accomplish this in two ways, the first is after we create the list:

```{r}
names(country_list) = c('countries', 'continents', 'populations')
country_list
```

And the second is to name them as we create the list:

```{r}
country_list = list(countries = countries, continents = continents, populations = country_populations)
country_list
```

## Data Frames

Of all the data types we've seen so far, matrices come closest to the idea of a spreadsheet you might encounter in Excel. However, matrices can only be all `character`, `double`, `logical`, etc, so they're not quite an analogue.

Data frames group vectors together into a two-dimensional table, where each vector becomes a column of the table. The data types within each column must be the same (they are vectors after all), but the columns can be of different data types. Let's construct our first data frame using some vectors we have laying around. Here we will include column names from the start:

```{r}
country_df = data.frame(countries = countries, continents = continents, populations = country_populations)
country_df
typeof(country_df)
class(country_df)
```

Notice that since the names of all the vectors are those of the countries, the row names are named in the same manner.

# Summary

The following figure is a helpful way to summarize what we've learned about the objects in R. There are objects that only allow a single type of data: vectors, matrices, and arrays. There are other objects that allow multiple types of data: lists and data frames. The types of data that we encountered are doubles, characters, and logicals.

<img src="images/r_data_structures.png" alt="R data structures" style="width:1000px;"/>
